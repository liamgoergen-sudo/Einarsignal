<!doctype html>
<html lang="de">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"/>
<title>Einar zeigt dir die Signale</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css"/>
<style>
  html, body, #map { height: 100%; margin:0; padding:0; -webkit-overflow-scrolling: touch; }
  #map { width: 100%; }

  #controls {
    position: absolute;
    top: 10px; left: 10px;
    background: rgba(255,255,255,0.95);
    padding: 12px;
    border-radius: 12px;
    font-family: sans-serif;
    z-index: 1000;
    box-shadow: 0 2px 6px rgba(0,0,0,0.3);
    max-width: 240px;
    touch-action: manipulation;
  }

  #controls h3 { margin-top: 0; font-size: 1.1em; }
  #controls button {
    display: block;
    width: 100%;
    margin: 6px 0;
    padding: 12px;
    font-size: 1em;
    border: none;
    border-radius: 10px;
    background: #0066cc;
    color: white;
    cursor: pointer;
  }
  #controls button:hover { background: #004a99; }
  #status { margin-top: 8px; font-size: 0.85em; color:#333; }
  #anzeige { margin-top: 4px; font-weight: bold; font-size: 1em; color: #cc0000; }

  /* Warnbox */
  #warnung {
    position: absolute;
    bottom: 10px; left: 10px; right: 10px;
    background: rgba(255,255,204,0.95);
    border: 2px solid #cc0000;
    color: #000;
    padding: 10px;
    font-size: 0.9em;
    border-radius: 10px;
    z-index: 1500;
    display: none;
  }
</style>
</head>
<body>

<div id="map"></div>

<div id="controls">
  <h3>Einar zeigt dir die Signale</h3>
  <button id="btnStart">Signal erwarten!</button>
  <button id="btnFahrtErkannt">Fahrt erkannt</button>
  <button id="btnAbbrechen">Abbrechen</button>
  <div id="status">Status: inaktiv</div>
  <div id="anzeige">—</div>
</div>

<div id="warnung"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
<script>
  const warnungEl = document.getElementById("warnung");

  const map = L.map('map').setView([51.0, 10.0], 6);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '© OpenStreetMap'
  }).addTo(map);
  L.tileLayer('https://{s}.tiles.openrailwaymap.org/signals/{z}/{x}/{y}.png', {
    maxZoom: 19, attribution: '© OpenRailwayMap'
  }).addTo(map);

  let watchId = null;
  let countdownEnabled = false;
  let posMarker = null;
  let signalMarkers = [];
  const anzeigeEl = document.getElementById("anzeige");
  const statusEl = document.getElementById("status");

  // Buttons
  document.getElementById("btnStart").addEventListener("click", () => {
    countdownEnabled = true;
    statusEl.textContent = "Countdown läuft...";
    startTracking();
  });

  document.getElementById("btnFahrtErkannt").addEventListener("click", () => {
    countdownEnabled = false;
    statusEl.textContent = "Fahrt erkannt – Countdown pausiert.";
  });

  document.getElementById("btnAbbrechen").addEventListener("click", () => {
    countdownEnabled = false;
    statusEl.textContent = "Abgebrochen.";
    if (watchId) navigator.geolocation.clearWatch(watchId);
  });

  // Start Positionstracking mit Fehlererkennung
  function startTracking() {
    if (!("geolocation" in navigator)) {
      showWarning("⚠️ Dein Gerät unterstützt keine Standortbestimmung.");
      return;
    }

    if (!watchId) {
      watchId = navigator.geolocation.watchPosition(
        pos => {
          hideWarning();
          const { latitude, longitude } = pos.coords;
          updatePosition(latitude, longitude);
          loadSignals(latitude, longitude);
        },
        err => handleGeoError(err),
        { enableHighAccuracy: true, timeout: 15000, maximumAge: 10000 }
      );
    }
  }

  function handleGeoError(err) {
    let msg = "⚠️ Standort kann nicht abgerufen werden.";
    if (err.code === 1) {
      msg = "⚠️ Standortzugriff wurde blockiert. Bitte in Safari → aA → Website-Einstellungen → Standortzugriff → Erlauben.";
    } else if (err.code === 2) {
      msg = "⚠️ Kein Standortsignal. Prüfe GPS oder Internetverbindung.";
    } else if (err.code === 3) {
      msg = "⚠️ Zeitüberschreitung beim Standortabruf.";
    }
    showWarning(msg);
    console.warn("GeoError:", err);
  }

  function showWarning(text) {
    warnungEl.textContent = text;
    warnungEl.style.display = "block";
  }
  function hideWarning() {
    warnungEl.style.display = "none";
  }

  function updatePosition(lat, lon) {
    if (!posMarker) {
      posMarker = L.marker([lat, lon]).addTo(map);
      map.setView([lat, lon], 15);
    } else {
      posMarker.setLatLng([lat, lon]);
    }
  }

  async function loadSignals(lat, lon) {
    const query = `
      [out:json][timeout:25];
      (
        node["railway"="signal"](around:2000,${lat},${lon});
      );
      out body;
    `;
    try {
      const response = await fetch("https://overpass-api.de/api/interpreter", {
        method: "POST",
        body: query,
      });
      const data = await response.json();

      signalMarkers.forEach(m => map.removeLayer(m));
      signalMarkers = [];

      if (!data.elements || data.elements.length === 0) {
        anzeigeEl.textContent = "Kein Signal gefunden.";
        return;
      }

      let nearest = null;
      let minDist = Infinity;
      data.elements.forEach(el => {
        const dist = haversine(lat, lon, el.lat, el.lon);
        if (dist < minDist) { minDist = dist; nearest = el; }
        const m = L.circleMarker([el.lat, el.lon], {radius:5, color:"red"}).addTo(map);
        m.bindPopup("Signal");
        signalMarkers.push(m);
      });

      if (nearest && countdownEnabled) updateAnzeige(minDist);

    } catch(e) {
      console.error("Overpass Fehler", e);
    }
  }

  function updateAnzeige(distance) {
    let msg = null;
    if (distance <= 200) msg = "Weniger als 200 m";
    else if (distance <= 300) msg = "Weniger als 300 m";
    else if (distance <= 400) msg = "Weniger als 400 m";
    else if (distance <= 500) msg = "Weniger als 500 m";

    if (msg && msg !== anzeigeEl.textContent) {
      anzeigeEl.textContent = msg;
      let utter = new SpeechSynthesisUtterance(msg);
      speechSynthesis.speak(utter);
    }
  }

  function haversine(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = deg => deg * Math.PI/180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a = Math.sin(dLat/2)**2 +
              Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*
              Math.sin(dLon/2)**2;
    return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  }
</script>
</body>
</html>
